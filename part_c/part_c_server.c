/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

/**
 * @file part_c_server.c
 * @author Elif Kızılkaya
 
 * @brief Part_a code is upgraded to Remote Procedure Call (RPC)
 * so that server can execute the blackbox (unknown executable file) 
 * for any client that requests. To achieve this, RPCGEN is used.
 * I made edits on the automatically generated code. In server, the 
 * main program creates a child process. It takes input from stdin and
 * pass it to the child via pipe. The child executes the executable
 * file with the given input. Afterwards, main program recevies
 * the output via pipe. The output is written to the result which
 * goes to the client. In addition to part_b, it creates a socket
 * in order to send the inputs and output of the blackbox to the 
 * logger program through the given port.
 *
 * How to compile and run:
    make
    ./part_c_logger.out part_c.log PORT_NUMBER &
    ./part_c_server.out LOGGER_IP_ADDRESS PORT_NUMBER &
    ./part_c_client.out blackbox part_c_output.txt SERVER_IP_ADDRESS
 */

/*
* REFERENCES:
* Unix - how to get IP address of domain name? Stack Overflow. 
  Retrieved December 15, 2021, from https://stackoverflow.com/questions/10403238/unix-how-to-get-ip-address-of-domain-name

* Socket programming in C/C++. GeeksforGeeks. (2019, May 31). 
  Retrieved December 15, 2021, from https://www.geeksforgeeks.org/socket-programming-cc/  

* TCP server-client implementation in C. GeeksforGeeks. (2021, September 23). 
  Retrieved December 15, 2021, from https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/  

*/

#include "part_c.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include<netdb.h>

/*
*   This code includes instances from CMPE322 PS6 18.11.2021
*   From the files: io_capture.c & bidirectional_pipe.c & redirect.c & add_server.c
*/

int input1;
int input2;
char r_buffer[10000];

extern char * ip_addr; //IP address of the logger
extern char * port; //Port number of logger

/*
*   This automatically generated function is the server function which does 
*   the job of the main program in part_a.
*/
char **
part_c_1_svc(parameters *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

    /*
    *   This part may contain examples from the following files:
    *   CMPE322 PS6 18.11.2021 io_capture.c & bidirectional_pipe.c & add_server.c
    */

    /*
    *   Those are sent from the client.
    */
    input1 = argp->number1;
	input2 = argp->number2;

	/**
     * p2c -> parent to child pipe
     * c2p -> child to parent pipe
     */
    int     p2c[2], c2p[2], nbytes;
    pid_t   pid;
    char w_buffer[1000];  

    /**
     * The parent creates both pipes, which will be shared between the parent and the child.
     */
    pipe(p2c);
    pipe(c2p);

    if((pid=fork()) == -1) {
        fprintf(stderr, "fork() failed.\n");
        exit(-1);
    }

    if(pid > 0) {
        /**
         * This is the code for the parent process.
         */

        /**
         * The parent should close the ends of the pipes that it will not use.
         */
        close(p2c[0]);    // Parent will not read from p2c
        close(c2p[1]);    // Parent will not write to c2p      
        
        /**
         * Send a request message to the child process.
         * Write message to the buffer, buf1
         */

        char buf1[256];
        sprintf(buf1, "%d %d", input1, input2);
        write(p2c[1], buf1, (strlen(buf1) + 1));
        
        /*
        *   Reading the response from the child to r_buffer 
        *   varibale. The child return an error text or an 
        *   integer value as the output of the executable file. 
        *  
        *   First, we empty the buffer with memset() function.
        */
       memset(r_buffer, 0, 10000);
       nbytes = read(c2p[0], r_buffer, sizeof(r_buffer));
       



    /*
    *    Converting domain name of the host to the ip address
    *    I utilized from this website to convert the host name to the ip address:
    *    https://stackoverflow.com/questions/10403238/unix-how-to-get-ip-address-of-domain-name
    */
    
    struct hostent* host;
    host = gethostbyname(ip_addr);
    char *ip_address = inet_ntoa(*(struct in_addr *)host->h_addr);
   
   
/*
    While writing this code, I utilized from the codes & explanations
    in the following websites;
    1) https://www.geeksforgeeks.org/socket-programming-cc/
    2) https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/
*/

    int sockt = 0;
    struct sockaddr_in log_address;
    char msg[1000];
    /*
    *  Create the socket with domain: IPv4 protocol and type: TCP
    */
    sockt = socket(AF_INET, SOCK_STREAM, 0);

    if (sockt < 0)
    {
        printf("\nSocket could not be created\n");
        exit(1);
    }
   
   /*
   *  Specify the port and address family
   */
    log_address.sin_family = AF_INET; // (IPv4 protocol)
    log_address.sin_port = htons(atoi(port)); //port is given beforehand
    
    /* 
    * Converting IPv4 address from text to binary form
    */
    if(inet_pton(AF_INET, ip_address, &log_address.sin_addr)<=0) //ip_address is the IP address of logger
    {
        printf("\nAddress is invalid or address is not supported\n");
        exit(1);  
    }

   /*
   * Connect the socket to the log_address
   */
    if (connect(sockt, (struct sockaddr *)&log_address, sizeof(log_address)) < 0)
    {
        printf("\nConnection could not be established\n");
         exit(1);
    }

        /*  This part is checking whether the response from child
         *  is error or integer.
         *   
         *  If it is integer, then converting to int and then converting
         *  to string would not effect the size. However, converting a text
         *  to int would make the size of the r_buffer 1.
         *  That is why, 1 is added in the if condition.
         *
         *   I utilized from the idea from this forum:
         *   https://stackoverflow.com/questions/16644906/how-to-check-if-a-string-is-a-number
         */

        char text[1000];
        sprintf(text, "%d", atoi(r_buffer)); //convert to int with atoi; then convert to string with sprintf
        
        /*
        *   If it is integer; then the sizes are equal.
        *   Send the message as it is.
        */
        if (strlen(r_buffer) == (strlen(text) + 1)) {
            bzero(msg, sizeof(msg)); //Empty the msg
            sprintf(msg, "%d %d %s", input1, input2, r_buffer); //Write to msg
        }
        /*
        *   If it is text; then the sizes are not equal.
        *   Error messages is written as '_' to the log file.
        */
        else {
            bzero(msg, sizeof(msg)); //empty the msg
            sprintf(msg, "%d %d _\n", input1, input2); //write to msg
        }
        /*
        *   Send the msg to the logger program through given port,
        *   using the socket.
        */
    send(sockt , msg , strlen(msg), 0);
    bzero(msg, sizeof(msg)); //Empty the msg
 
    }
        /*
        *   This part contains instances from the following file:
        *   CMPE322 PS6 18.11.2021 io_capture.c
        */
    else {
        /**
         * This is the code for the child process.
         */

        //Path is given by the client
        char * path1 = argp->path;
        
        /**
         * The child associates the read end of p2c with its own stdin.
         */
        dup2(p2c[0], STDIN_FILENO);
        /**
         * The child associates the write end of c2p with its own stdout and stderr.
         */
        dup2(c2p[1], STDOUT_FILENO);
        dup2(c2p[1], STDERR_FILENO);

    
        /**
         * The child can close all pipes since they are not needed anymore.
         */
        close(c2p[0]);
        close(c2p[1]);
        close(p2c[0]);
        close(p2c[1]);

        /*
        *   Replace the contents of the child process with the
        *   given executable file.
        *   path -> path of the executable
        *   ./blackbox -> command to execute the file
        */
        execl(path1, path1, NULL);  
          
    }
    /*
    *  Equate the response from the child to the result 
    *  and send the result to the client
    */
    result = r_buffer;
	return &result;
}