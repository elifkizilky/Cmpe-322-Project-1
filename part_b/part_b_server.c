/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

/**
 * @file part_b_server.c
 * @author Elif Kızılkaya
 
 * @brief Part_a code is upgraded to Remote Procedure Call (RPC)
 * so that server can execute the blackbox (unknown executable file) 
 * for any client that requests. To achieve this, RPCGEN is used.
 * I made edits on the automatically generated code. In server, the 
 * main program creates a child process. It takes input from stdin and
 * pass it to the child via pipe. The child executes the executable
 * file with the given input. Afterwards, main program recevies
 * the output via pipe. The output is written to the result which
 * goes to the client.

 * How to compile and run:
    make
    ./part_b_server.out &
    ./part_b_client.out blackbox part_b_output.txt SERVER_IP_ADDRESS
 */

#include "part_b.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>

/*
*   This code includes examples from CMPE322 PS6 18.11.2021
*   From the files: io_capture.c & bidirectional_pipe.c & redirect.c & add_server.c
*/

/*
*   This automatically generated function is the server function which does 
*   the job of the main program in part_a.
*/
char **
part_b_1_svc(parameters *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

    /*
    *   This part may contain examples from the following files:
    *   CMPE322 PS6 18.11.2021 io_capture.c & bidirectional_pipe.c & add_server.c
    */


    /*
    *   Those are sent from the client.
    */
	int input1 = argp->number1; 
	int input2 = argp->number2;

	/**
     * p2c -> parent to child pipe
     * c2p -> child to parent pipe
     */
    int     p2c[2], c2p[2], nbytes;
    pid_t   pid;
    char w_buffer[1000], r_buffer[10000];  

    /**
     * The parent creates both pipes, which will be shared between the parent and the child.
     */
    pipe(p2c);
    pipe(c2p);

    if((pid=fork()) == -1) {
        fprintf(stderr, "fork() failed.\n");
        exit(-1);
    }

    if(pid > 0) {
        /**
         * This is the code for the parent process.
         */

        /**
         * The parent should close the ends of the pipes that it will not use.
         */
        close(p2c[0]);    // Parent will not read from p2c
        close(c2p[1]);    // Parent will not write to c2p      
        
        /**
         * Send a request message to the child process.
         * Write message to the buffer, buf1
         */

        char buf1[256]; 
        sprintf(buf1, "%d %d", input1, input2);
        write(p2c[1], buf1, (strlen(buf1) + 1));
        
        /*
        *   Reading the response from the child to r_buffer 
        *   varibale. The child return an error text or an 
        *   integer value as the output of the executable file. 
        *  
        *   First, we empty the buffer with memset() function.
        */
        memset(r_buffer, 0, 10000);
        nbytes = read(c2p[0], r_buffer, sizeof(r_buffer));

    
    }
        /*
        *   This part may contain examples from the following file:
        *   CMPE322 PS6 18.11.2021 io_capture.c
        */
    else {
        /**
         * This is the code for the child process.
         */

        //Path is given by the client
        char * path1 = argp->path;
        /**
         * The child associates the read end of p2c with its own stdin.
         */
        dup2(p2c[0], STDIN_FILENO);
        /**
         * The child associates the write end of c2p with its own stdout and stderr.
         */
        dup2(c2p[1], STDOUT_FILENO);
        dup2(c2p[1], STDERR_FILENO);

    
        /**
         * The child can close all pipes since they are not needed anymore.
         */
        close(c2p[0]);
        close(c2p[1]);
        close(p2c[0]);
        close(p2c[1]);

        /*
        *   Replace the contents of the child process with the
        *   given executable file.
        *   path -> path of the executable
        *   ./blackbox -> command to execute the file
        */
        execl(path1, path1, NULL);  
          
    }

    /*
    *  Equate the response from the child to the result 
    *  and send the result to the client
    */
    
    result = r_buffer;
	return &result;
}
